\documentclass[letterpaper]{article} 
\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{\small Research Statement. Aurojit Panda}
\lhead{}
\renewcommand{\headrulewidth}{0pt}
\newcommand\eat[1]{}
\begin{document}
\title{\Large Research Statement}
\author{Aurojit Panda}
\date{}
\thispagestyle{empty}
\maketitle
Networks increasingly provide higher level services and functionality beyond packet forwarding. These services
are often provided by middleboxes which are increasingly built using commodity server hardware, with
processing carried out in software. This move to a common hardware platform has in turn allowed network
providers to rapidly deploy newer services; Network Function Virtualization (NFV) makes it so one can deploy
new network functionality using similar tools to those used to provision and deploy new web services.
Simplifying and hastening the rate at which network services can be deployed and an increasing reliance on
commodity servers means that network operators can now allow service providers and customers to deploy
services on the network. Recent trends like ISP provided CDNs, the large computation power available in IXP
datacenters, etc. seem to point to a trend where carrier networks become available as a platform.

At the same time networks continue to be a critical infrastructure and network operators must ensure that new
services and policies do not violate the correctness of their networks. Traditionally the network data plane
and control plane were tightly couples and network infrastructure evolved slowly, allowing network operators
time to exhaustively test software and hardware before deploying it on their network. More recently however
Software Defined Networking (SDN) has meant that the network control plane can evolve independent of the data
plane. This in conjunction with the trend towards NFV has increased the need for quick, automatic verification
of network behavior. Recent work~\cite{khurshid13veriflow, kazemian2012header} has looked at verifying the
correctness of forwarding tables (i.e., ensuring that the network is loop free, etc.). This work however does
not account for dynamic data path behavior exhibited by many middleboxes and hence provides an incomplete
analysis for many networks.

My recent research has focused on the intersection of both these trends. I have been looking at applying
techniques from the Programming Languages literature to verify administrator provided invariants (for instance
isolation, ensuring traversal, etc.) for networks with dynamic elements like middleboxes. Some of my other
research has separately focused on the architecture and design of primitives that application developers can
use to take advantage of network operator provided services. These primitives allow application developers to
query the network for additional information and to effectively use services instantiated by the network
operator.

\section*{Network Verification}
SDN has enabled the modularization of network control planes providing software with a well defined API for
affecting the data plane. Modularization has resulted in centralization which allows software to observe
forwarding state across the network. Simultaneously the use of a common API allows software to reason about
the semantics of the network data plane based upon this forwarding state. Recent work like Header Space
Analysis (HSA)~\cite{kazemian2012header} and Veriflow~\cite{khurshid13veriflow} have used these properties to
verify forwarding state and provide tools to reason about forwarding paths. 

Both HSA and Veriflow can be used to verify the network transfer function, i.e., the paths traversed by
packets given the set of forwarding tables installed in the data path. These techniques however have a few
important limitations: 1. They assume that forwarding state is only modified by the control plane, i.e.,
data plane behavior is only affected by control plane actions. This assumption is violated by several network
elements; for instance, learning switches and stateful firewalls depend on previous data path traffic. 2.
HSA can handle changes to the layer 3 (and layer 2) headers of a packet but does not account for modifications to the
packet payload. Middleboxes are often application specific and can be affected by changes to the packet
payload. 3. The specific techniques used are tractable in part because of the limited set of operations provided by
router ASICs. In particular it is not tractable to extend a similar form of reasoning to general purpose
packet processors of the kind used in middleboxes.

Recent studies~\cite{sherry2012making} show that enterprise networks (including extremely large networks with
over $100,000$ hosts) on average contain as many middleboxes as layer 3 routers. Similarly non-forwarding
boxes are widely used in carrier networks, for tasks such as caching, deep-packet inspection, providing
customer isolation, etc. Packets in these networks commonly pass through several dynamic elements and overall
network behavior depends on the result of processing on all of these elements. Furthermore, these elements do
not act in isolation: a WAN optimizer can adversely affect the behavior of an application level firewall, even
in the absence of configuration errors.

Concurrently there is a lot of interest in the formal verification of software resulting in tools
like KLEE~\cite{cadar2008klee}, etc. and in efforts to verify large systems software~\cite{klein2009sel4}.
Recent work~\cite{dobrescu2014software} has shown how to take advantage of these techniques to verify the
correctness of a single software dataplane element, for instance a middlebox. Many of these works have relied
on model checking, an approach to formal verification where one generates a mathematical model for the
program, i.e., the set of states the program can be in and transitions between those states. Given this model
one can prove or disprove correctness by systematically exploring all possible states and checking if a
disallowed state is ever reached. Model checking has been well studied in the programming language
literature~\cite{jhala2009software, han2007providing} since it requires little or no changes to the underlying
program and places no limitations on the programs behavior. Model checking however generally does not scale to
large systems, performance degrades rapidly with an increase in the size of the state space. 

My research focuses on techniques that would allow HSA and Veriflow style verification of network wide
behavior for networks with complex data path elements such as middleboxes. Using model checking to do this is
appealing since it requires no assumptions about the semantics of data path elements. However directly
combining models generated from middlebox code is not scalable.  
\bibliographystyle{abbrv}
\bibliography{bibs}
\end{document}
